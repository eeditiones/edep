<?xml-model href="teipublisher_odds.xsd"?><?teipublisher output="web print"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:pb="http://teipublisher.com/1.0" xml:lang="en">
    <teiHeader>
        <fileDesc>
            <titleStmt>
                <title>EDEp - edition</title>
            </titleStmt>
            <publicationStmt>
                <publisher>eXistSolutions GmbH</publisher>
                <availability>
                    <licence target="https://www.gnu.org/licenses/gpl-3.0.en.html">Distributed under GNU General Public License</licence>
                    <p>Copyright 2017
                        <ref target="http://existsolutions.com">eXistSolutions GmbH</ref>
                    </p>
                    <p>This program is free software: you can redistribute it and/or modify
                        it under the terms of the GNU General Public License as published by
                        the Free Software Foundation, either version 3 of the License, or
                        (at your option) any later version.</p>
                    <p>This program is distributed in the hope that it will be useful,
                        but WITHOUT ANY WARRANTY; without even the implied warranty of
                        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                        GNU General Public License for more details.</p>
                </availability>
            </publicationStmt>
            <sourceDesc>
                <p>Generated by
                    <ref target="http://tei-publisher.com">TEI Publisher</ref>
                </p>
                <p>born digital</p>
            </sourceDesc>
        </fileDesc>
        <encodingDesc>
            <tagsDecl>
                <rendition source="edep.css"/>
            </tagsDecl>
        </encodingDesc>
        <revisionDesc>
            <change when="2023-09-13Z">Initial version</change>
        </revisionDesc>
    </teiHeader>
    <text>
        <body>
            <schemaSpec start="TEI teiCorpus" ident="edep-edition" source="edep.odd">
                            <elementSpec ident="teiHeader" mode="change">
                    <modelSequence predicate="$parameters?view='metadata'">
            <desc>Create metadata sections</desc>
            <model behaviour="block">
                <param name="objectType" value="let $vocab := doc('/db/apps/edep-data/objtyp.xml') let $uris := tokenize(descendant::objectType/@ref, '\s+') for $uri in $uris return if ($uri) then  &lt;row type=&#34;metadata&#34;&gt; &lt;cell&gt;form.type-of-monument&lt;/cell&gt; &lt;cell&gt;&lt;term&gt;{$vocab//*[local-name() eq 'term'][@ref = $uri]/*}&lt;/term&gt;&lt;/cell&gt; &lt;/row&gt;  else ()"/>
                <param name="material" value="let $vocab := doc('/db/apps/edep-data/material.xml') let $uris := tokenize(descendant::material/@ref, '\s+') for $uri in $uris return &lt;cell&gt;&lt;term&gt;{$vocab//*[local-name() eq 'term'][@ref = $uri]/node()}&lt;/term&gt;&lt;/cell&gt;"/>
                <param name="description" value="let $desc := descendant::support/note/string() return if($desc) then &lt;row type=&#34;metadata&#34;&gt; &lt;cell&gt;form.description-of-monument&lt;/cell&gt; &lt;cell&gt;{$desc}&lt;/cell&gt; &lt;/row&gt; else ()"/>
                <param name="dimensions" value="let $dimensions:= descendant::msPart[@type eq 'main']/descendant::supportDesc/descendant::dimensions/*/text() return if ($dimensions) then &lt;row type=&#34;metadata&#34;&gt; &lt;cell&gt;metadata.dimensions&lt;/cell&gt; &lt;cell&gt;{string-join($dimensions, ' × ')}&lt;/cell&gt; &lt;/row&gt; else ()"/>
                <param name="condition" value="let $condition := descendant::msPart[@type eq 'main']/descendant::condition return 'preservation.' || $condition"/>
                <param name="decoration" value="let $vocab := doc('/db/apps/edep-data/decor.xml') let $uris := tokenize(descendant::msPart[@type eq 'main']/descendant::supportDesc/descendant::rs[@type eq 'decoration']/@ref, '\s+') for $uri in $uris return $vocab//*[local-name() eq 'item'][@value = $uri]/@name"/>
                <param name="findContext" value="let $note := descendant::msPart[@type eq 'main']/descendant::provenance[@type eq 'found']/note/string() return if ($note) then &lt;row type=&#34;metadata&#34;&gt;&lt;cell&gt;form.context-of-provenance&lt;/cell&gt;&lt;cell&gt;{$note}&lt;/cell&gt;&lt;/row&gt; else ()"/>
                <param name="findDate" value="let $element := descendant::msPart[@type eq 'main']/descendant::provenance[@type eq 'found'] let $range := $element/@notBefore || ' – ' || $element/@notAfter let $exact := $element/@when let $string := $element/@when-custom return if ($exact and $string) then $exact || ' (' || $string || ')' else if ((string-length($range) gt 1) and $string) then $range || ' (' || $string || ')' else if ($exact) then ($exact) else if (string-length($range) gt 1) then $range else $string"/>
                <param name="modernLocation" value="descendant::msPart[@type eq 'main']/msIdentifier/repository"/>
                <param name="tmID" value="let $tmid := descendant::msPart[@type eq 'main']/descendant::idno[@type eq 'TM'] return  if ($tmid) then  &lt;row type=&#34;metadata&#34;&gt;&lt;cell&gt;form.tm&lt;/cell&gt;&lt;cell&gt;{$tmid}&lt;/cell&gt;&lt;/row&gt; else ()"/>
                <param name="palaeography" value="let $vocab := doc('/db/apps/edep/templates/fore/data/palaeographie.xml') let $rs := descendant::msPart[@type eq 'main']/descendant::rs[@type eq 'palaeography'] let $uris := tokenize($rs/@ref, '\s+')  return if ($rs[@ref]) then &lt;row type=&#34;metadata&#34;&gt;&lt;cell&gt;form.palaeography&lt;/cell&gt;&lt;cell&gt;&lt;term&gt;{for $uri in $uris return $vocab//*[local-name() eq 'item'][@ref = $uri]/*}&lt;/term&gt;&lt;/cell&gt;&lt;/row&gt;   else ()"/>
                <param name="letterSize" value="string-join(descendant::msPart[@type eq 'main']/descendant::handDesc/descendant::dimensions[@type eq 'letterHeight']/*, ' × ')"/>
                <param name="fieldDesc" value="let $fieldDesc := descendant::msPart[@type eq 'main']/descendant::layout/ab return if ($fieldDesc) then &lt;row type=&#34;metadata&#34;&gt;&lt;cell&gt;form.description&lt;/cell&gt;&lt;cell&gt;{$fieldDesc}&lt;/cell&gt;&lt;/row&gt; else ()"/>
                <param name="provenanceHistory" value="let $history := descendant::msPart[@type eq 'main']/descendant::provenance[@type eq 'history']/node() return if ($history) then &lt;row type=&#34;metadata&#34;&gt;&lt;cell&gt;form.other-events&lt;/cell&gt;&lt;cell&gt;{$history}&lt;/cell&gt;&lt;/row&gt; else ()"/>
                <param name="inscriptionType" value="let $vocab := doc('/db/apps/edep-data/typeins.xml') let $uris := tokenize(descendant::msPart[@type eq 'main']/descendant::msItem/@class, '\s+') for $uri in $uris return &lt;cell&gt;&lt;term&gt;{$vocab//*[local-name() eq 'term'][@ref = $uri]/node()}&lt;/term&gt;&lt;/cell&gt;"/>
                <param name="metre" value="descendant::msPart[@type eq 'main']/descendant::rs[@type eq 'metric']"/>
                <param name="language" value="let $element := descendant::msPart[@type eq 'main']/descendant::textLang return string-join(($element/@mainLang, tokenize($element/@otherLangs, '\s+')), ', ')"/>
                <param name="date" value="let $element := descendant::origDate let $range := $element/@notBefore-custom || ' – ' || $element/@notAfter-custom let $exact := $element/@when-custom let $string := $element/string() return if ($exact) then $string || ' (' || $exact || ')' else if ($range) then $string || ' (' || $range || ')' else $string"/>
                <param name="religion" value="let $attVal := descendant::keywords[@scheme eq 'https://edh.ub.uni-heidelberg.de/edep/religion']/term/@ref return 'religion.' || substring($attVal, 2)"/>
                <param name="historicRelevance" value="let $terms := descendant::keywords[@scheme eq 'https://edh.ub.uni-heidelberg.de/edep/terms']/term/@ref return if ($terms) then  &lt;row type=&#34;metadata&#34;&gt;&lt;cell&gt;form.historic-relevance&lt;/cell&gt;&lt;cell&gt;{ for $term in $terms return &lt;seg n=&#34;form.{substring($term, 2)}&#34;/&gt; }&lt;/cell&gt;&lt;/row&gt; else ()"/>
                <param name="ligature" value="descendant::msPart[@type eq 'main']/descendant::handDesc/descendant::rs[@type eq 'ligature']"/>
                <param name="fieldDimensions" value="let $dimensionsEls := descendant::msPart[@type eq 'main']/descendant::layout/dimensions/*/text() return if ($dimensionsEls) then &lt;row&gt;&lt;cell&gt;metadata.dimensions&lt;/cell&gt;&lt;cell&gt;{string-join($dimensionsEls, ' × ')}&lt;/cell&gt;&lt;/row&gt; else ()"/>
                <param name="verification" value="let $subtype := descendant::msPart[@type eq 'main']/descendant::note[@type eq 'verification']/@subtype return 'verification.' || $subtype"/>
                <param name="verificationDate" value="descendant::msPart[@type eq 'main']/descendant::note[@type eq 'verification']/date/@when"/>
                <param name="findSpot" value="let $id := descendant::msPart[@type eq 'main']/descendant::origPlace/@corresp   let $place := collection('/db/apps/edep-data/places')/id($id) let $label := $place/placeName[@type eq 'findspot']/string() let $geo := tokenize($place/location/geo, ',\s*') return  &lt;pb-geolocation xmlns=&#34;http://www.w3.org/1999/xhtml&#34; event=&#34;click&#34; longitude=&#34;{$geo[2]}&#34; latitude=&#34;{$geo[1]}&#34; label=&#34;{label}&#34;&gt;{$label}&lt;/pb-geolocation&gt;"/>
                <param name="modernPlace" value="let $id :=  descendant::origPlace/@corresp let $place := collection('/db/apps/edep-data/places')/id($id)  let $label := $place/placeName[@type eq 'modern'] || ' (' || $place/region[@type eq 'modern'] || ', ' || upper-case($place/country) || ')' return  if ($id) then &lt;row type=&#34;metadata&#34;&gt;&lt;cell&gt;metadata.modern-place&lt;/cell&gt;&lt;cell&gt;{$label}&lt;/cell&gt;&lt;/row&gt; else ()"/>
                <param name="ancientPlace" value="let $id := descendant::msPart[@type eq 'main']/descendant::origPlace/@corresp let $place := collection('/db/apps/edep-data/places')/id($id)  let $label := $place/placeName[@type eq 'ancient'] || ' (' || $place/region[@type eq 'province'] || ')' return  if ($id) then &lt;row type=&#34;metadata&#34;&gt;&lt;cell&gt;metadata.ancient-place&lt;/cell&gt;&lt;cell&gt;{$label}&lt;/cell&gt;&lt;/row&gt; else ()"/>
                <param name="bibl" value="descendant::msPart[@type eq 'main']/descendant::listBibl"/>
                <param name="biblHeader" value="if (descendant::listBibl) then &lt;h2 xmlns=&#34;http://www.w3.org/1999/xhtml&#34;&gt;&lt;pb-i18n key=&#34;form.references&#34;/&gt;&lt;/h2&gt; else ()"/>
                <pb:template xmlns="" xml:space="preserve"><div class="metadata">
            <section class="main objectDesc">
                <h2><pb-i18n key="form.object-description"/></h2>
                <table>
                    <tbody>
                      [[objectType]] 
                        <tr>
                            <th><pb-i18n key="form.material"/></th>
                            [[material]]
                        </tr>
                        [[description]] 
                        [[dimensions]] 
                        <tr>
                            <th><pb-i18n key="form.preservation"/></th>
                            <td><pb-i18n key="[[condition]]"/></td>
                        </tr>
                        <tr>
                            <th><pb-i18n key="form.decoration"/></th>
                            <td>[[decoration]]</td>
                        </tr>
                        <tr>
                            <th><pb-i18n key="form.findspot"/></th>
                            <td>[[findSpot]]</td>
                        </tr>                 
                        [[modernPlace]]
                        [[ancientPlace]]
                        [[findContext]]
                        <tr>
                            <th><pb-i18n key="form.year-of-find"/></th>
                            <td>[[findDate]]</td>
                        </tr>
                        <tr>
                            <th><pb-i18n key="form.last-recorded-location"/></th>
                            <td>[[modernLocation]]</td>
                        </tr>
                      [[tmID]] 
                    </tbody>
                </table>    
            </section>
            <section class="main inscription">
                <h2><pb-i18n key="form.inscription-field"/></h2>
                <table>
                    <tbody>
                       [[fieldDimensions]]
                         <tr>
                            <th><pb-i18n key="form.letter-size"/></th>
                            <td>[[letterSize]]</td>
                        </tr>
                        [[palaeography]]        
                        <tr>
                            <th><pb-i18n key="form.ligature"/></th>
                            <td>[[ligature]]</td>
                        </tr>                      
                        [[fieldDesc]]
                    </tbody>
                </table>                
            </section>         
            <section class="main text">
                <h2><pb-i18n key="form.text-description"/></h2>
                <table>
                    <tbody>                      
                        <tr>
                            <th><pb-i18n key="form.type-of-inscription"/></th>
                            [[inscriptionType]]
                        </tr>
                        <tr>
                            <th><pb-i18n key="form.metre"/></th>
                            <td>[[metre]]</td>
                        </tr>
                        <tr>
                            <th><pb-i18n key="form.language"/></th>
                            <td>[[language]]</td>
                        </tr>
                        <tr>
                            <th><pb-i18n key="form.dating"/></th>
                            <td>[[date]]</td>
                        </tr>
                        <tr>
                            <th><pb-i18n key="form.religion"/></th>
                            <td><pb-i18n key="[[religion]]"/></td>
                        </tr>                        
                           [[historicRelevance]]
                    </tbody>
                </table>               
            </section>
          <section class="main additional">
            <h2><pb-i18n key="metadata.additional"/></h2>
            <table>              
              <tbody>
                <tr>
                            <th><pb-i18n key="form.basis-of-verification"/></th>
                            <td><pb-i18n key="[[verification]]"/></td>
                        </tr>
                        <tr>
                            <th><pb-i18n key="form.date-of-verification"/></th>
                            <td>[[verificationDate]]</td>
                        </tr>    
               [[provenanceHistory]] 
              </tbody>
                        
            </table>
            </section>
            <section class="main references">
              [[biblHeader]]
              [[bibl]]
          </section>
        </div></pb:template>
            </model>
            <model behaviour="block">
                <param name="content" value="descendant::msPart[@type eq 'fragment']"/>
            </model>
            <model predicate="descendant::listBiblll" behaviour="pass-through"/>
        </modelSequence>
                    <model output="latex" behaviour="metadata"/>
                    <model output="fo" behaviour="omit"/>
                    <model output="web" predicate="$parameters?header='short'" behaviour="block"/>
                    <model output="web" behaviour="metadata"/>
                </elementSpec>
                
                <elementSpec ident="*" mode="add"/>
                <elementSpec ident="row" mode="change">
                    <model predicate="@type eq 'metadata'" behaviour="inline">
            <desc>Within the metadata table, model for post-processing</desc>
            <param name="th" value="cell[1]"/>
            <param name="td" value="cell[2]/node()"/>
            <pb:template xmlns="" xml:space="preserve"><tr>
  <th><pb-i18n key="[[th]]"/></th>
  <td>[[td]]</td>
</tr></pb:template>
        </model>
                    <model predicate="@role='label'" behaviour="row">
            <outputRendition xml:space="preserve">
            font-weight: bold;
            </outputRendition>
        </model>
                    <model behaviour="row">
            <desc>Insert table row. </desc>
        </model>
                </elementSpec>
                <elementSpec ident="seg" mode="change">
                    <model predicate="ancestor::row[@type eq 'metadata']" behaviour="block">
            <desc>Within the metadata table, model to create a pb-i18n element when the key is computed</desc>
            <param name="key" value="@n"/>
            <pb:template xmlns="" xml:space="preserve"><pb-i18n key="[[key]]"/></pb:template>
        </model>
                    <model behaviour="inline" useSourceRendition="true"/>
                </elementSpec>                 
            <elementSpec ident="div" mode="change">
                    <modelSequence predicate="@type = ('translation', 'apparatus', 'textpart') and child::node() and (@type = following-sibling::div/@type or @type = preceding-sibling::div/@type)">
            <desc>Creation of subheadings when there are multiple fragments</desc>
            <model behaviour="heading">
                <param name="level" value="3"/>
                <param name="key" value="if (@type eq 'textpart') then 'edition' else @type"/>
                <param name="type" value="let $id := substring(@corresp, 2) let $msPart := root(.)/descendant::msPart[@xml:id = $id] return $msPart/@type"/>
                <param name="count" value="let $id := substring(@corresp, 2) let $msPart := root(.)/descendant::msPart[@xml:id = $id]  return if ($msPart[@type eq 'fragment']) then count($msPart/preceding-sibling::msPart[@type eq 'fragment']) + 1 else ()"/>
                <pb:template xmlns="" xml:space="preserve"><pb-i18n key="form.[[key]]"/> <span> – </span> <pb-i18n key="form.part-[[type]]"/> <span> 
  [[count]]</span></pb:template>
            </model>
            <model behaviour="block"/>
            <model predicate="@resp" behaviour="paragraph">
                <param name="content" value="'Translated by ' || @resp"/>
                <outputRendition xml:space="preserve">
                font-weight:bold
                </outputRendition>
            </model>
        </modelSequence>
                    <model predicate="@type='title_page'" behaviour="block">
            <outputRendition xml:space="preserve">
            border: 1px solid black; padding: 5px;
            </outputRendition>
        </model>
                    <model predicate="parent::body or parent::front or parent::back" behaviour="section"/>
                    <model behaviour="block"/>
                </elementSpec>
                <elementSpec ident="TEI" mode="change"/>
                <elementSpec ident="lb" mode="change">
                    <model predicate="not(preceding::lb)" behaviour="omit"/>
                    <modelSequence predicate="@break=&#34;no&#34;">
            <model behaviour="inline" cssClass="lb-hyphen">
                <param name="content" value="'-'"/>
            </model>
            <model behaviour="break" cssClass="lb">
                <param name="type" value="'line'"/>
                <param name="label" value="@n"/>
            </model>
            <model predicate="number(@n) mod 4 = 0" behaviour="inline" cssClass="number-lb lb">
                <param name="content" value="@n"/>
            </model>
        </modelSequence>
                    <modelSequence>
            <model behaviour="break" cssClass="lb">
                <param name="type" value="'line'"/>
                <param name="label" value="@n"/>
            </model>
            <model predicate="number(@n) mod 4 = 0" behaviour="inline" cssClass="number-lb lb">
                <param name="content" value="@n"/>
            </model>
        </modelSequence>
                </elementSpec>
                <elementSpec ident="ex" mode="change">
                    <model predicate="$parameters?mode='diplomatic' and not(ancestor::choice) and not(following-sibling::abbr) and not(preceding-sibling::abbr)" behaviour="alternate" cssClass="choice">
            <param name="default" value="if (./@cert='low')  then ('(',., '?)') else ('(',., ')')"/>
            <param name="alternate" value="'.'"/>
        </model>
                    <modelSequence predicate="not(ancestor::choice) and not(following-sibling::abbr) and not(preceding-sibling::abbr)">
            <model behaviour="alternate" cssClass="choice">
                <param name="default" value="'.'"/>
                <param name="alternate" value="if (./@cert='low')  then ('(',., '?)') else ('(',., ')')"/>
            </model>
            <model behaviour="alternate" cssClass="choice-alternate">
                <param name="default" value="if (./@cert='low')  then ('(',., '?)') else ('(',., ')')"/>
                <param name="alternate" value="'.'"/>
            </model>
        </modelSequence>
                </elementSpec>
                <elementSpec ident="msPart" mode="add">
                    <model predicate="(@type eq 'fragment') and $parameters?view='metadata'" behaviour="block">
            <param name="dimensions" value="let $dimensions:= descendant::supportDesc/descendant::dimensions/*/text() return if ($dimensions) then &lt;row type=&#34;metadata&#34;&gt; &lt;cell&gt;metadata.dimensions&lt;/cell&gt; &lt;cell&gt;{string-join($dimensions, ' × ')}&lt;/cell&gt; &lt;/row&gt; else ()"/>
            <param name="condition" value="let $condition := descendant::condition return 'preservation.' || $condition"/>
            <param name="decoration" value="let $vocab := doc('/db/apps/edep-data/decor.xml') let $uris := tokenize(descendant::supportDesc/descendant::rs[@type eq 'decoration']/@ref, '\s+') for $uri in $uris return $vocab//*[local-name() eq 'item'][@value = $uri]/@name"/>
            <param name="findContext" value="let $note := descendant::provenance[@type eq 'found']/note/string() return if ($note) then &lt;row type=&#34;metadata&#34;&gt;&lt;cell&gt;form.context-of-provenance&lt;/cell&gt;&lt;cell&gt;{$note}&lt;/cell&gt;&lt;/row&gt; else ()"/>
            <param name="findDate" value="let $element := descendant::provenance[@type eq 'found'] let $range := $element/@notBefore || ' – ' || $element/@notAfter let $exact := $element/@when let $string := $element/@when-custom return if ($exact and $string) then $exact || ' (' || $string || ')' else if ((string-length($range) gt 1) and $string) then $range || ' (' || $string || ')' else if ($exact) then ($exact) else if (string-length($range) gt 1) then $range else $string"/>
            <param name="modernLocation" value="msIdentifier/repository"/>
            <param name="tmID" value="let $tmid := descendant::idno[@type eq 'TM'] return  if ($tmid) then  &lt;row type=&#34;metadata&#34;&gt;&lt;cell&gt;form.tm&lt;/cell&gt;&lt;cell&gt;{$tmid}&lt;/cell&gt;&lt;/row&gt; else ()"/>
            <param name="palaeography" value="let $vocab := doc('/db/apps/edep/templates/fore/data/palaeographie.xml') let $rs := descendant::rs[@type eq 'palaeography'] let $uris := tokenize($rs/@ref, '\s+')  return if ($rs[@ref]) then &lt;row type=&#34;metadata&#34;&gt;&lt;cell&gt;form.palaeography&lt;/cell&gt;&lt;cell&gt;&lt;term&gt;{for $uri in $uris return $vocab//*[local-name() eq 'item'][@ref = $uri]/*}&lt;/term&gt;&lt;/cell&gt;&lt;/row&gt;   else ()"/>
            <param name="letterSize" value="string-join(descendant::handDesc/descendant::dimensions[@type eq 'letterHeight']/*, ' × ')"/>
            <param name="fieldDesc" value="let $fieldDesc := descendant::layout/ab return if ($fieldDesc) then &lt;row type=&#34;metadata&#34;&gt;&lt;cell&gt;form.description&lt;/cell&gt;&lt;cell&gt;{$fieldDesc}&lt;/cell&gt;&lt;/row&gt; else ()"/>
            <param name="provenanceHistory" value="let $history := descendant::provenance[@type eq 'history']/node() return if ($history) then &lt;row type=&#34;metadata&#34;&gt;&lt;cell&gt;form.other-events&lt;/cell&gt;&lt;cell&gt;{$history}&lt;/cell&gt;&lt;/row&gt; else ()"/>
            <param name="inscriptionType" value="let $vocab := doc('/db/apps/edep-data/typeins.xml') let $uris := tokenize(descendant::msItem/@class, '\s+') for $uri in $uris return &lt;cell&gt;&lt;term&gt;{$vocab//*[local-name() eq 'term'][@ref = $uri]/node()}&lt;/term&gt;&lt;/cell&gt;"/>
            <param name="metre" value="descendant::rs[@type eq 'metric']"/>
            <param name="language" value="let $element := descendant::textLang return string-join(($element/@mainLang, tokenize($element/@otherLangs, '\s+')), ', ')"/>
            <param name="ligature" value="descendant::handDesc/descendant::rs[@type eq 'ligature']"/>
            <param name="fieldDimensions" value="let $dimensionsEls := descendant::layout/dimensions/*/text() return if ($dimensionsEls) then &lt;row&gt;&lt;cell&gt;metadata.dimensions&lt;/cell&gt;&lt;cell&gt;{string-join($dimensionsEls, ' × ')}&lt;/cell&gt;&lt;/row&gt; else ()"/>
            <param name="verification" value="let $subtype := descendant::note[@type eq 'verification']/@subtype return 'verification.' || $subtype"/>
            <param name="verificationDate" value="descendant::note[@type eq 'verification']/date/@when"/>
            <param name="findSpot" value="'test'"/>
            <param name="modernPlace" value="let $id :=  descendant::origPlace/@corresp let $place := collection('/db/apps/edep-data/places')/id($id)  let $label := $place/placeName[@type eq 'modern'] || ' (' || $place/region[@type eq 'modern'] || ', ' || upper-case($place/country) || ')' return  if ($id) then &lt;row type=&#34;metadata&#34;&gt;&lt;cell&gt;metadata.modern-place&lt;/cell&gt;&lt;cell&gt;{$label}&lt;/cell&gt;&lt;/row&gt; else ()"/>
            <param name="ancientPlace" value="let $id := descendant::msPart[@type eq 'main']/descendant::origPlace/@corresp let $place := collection('/db/apps/edep-data/places')/id($id)  let $label := $place/placeName[@type eq 'ancient'] || ' (' || $place/region[@type eq 'province'] || ')' return  if ($id) then &lt;row type=&#34;metadata&#34;&gt;&lt;cell&gt;metadata.ancient-place&lt;/cell&gt;&lt;cell&gt;{$label}&lt;/cell&gt;&lt;/row&gt; else ()"/>
            <param name="bibl" value="descendant::listBibl"/>
            <param name="count" value="' ' || count(preceding-sibling::msPart[@type eq 'fragment']) + 1"/>
            <param name="biblHeader" value="if (descendant::listbibl) then &lt;h2 xmlns=&#34;http://www.w3.org/1999/xhtml&#34;&gt;&lt;pb-i18n key=&#34;form.references&#34;/&gt;&lt;/h2&gt; else ()"/>
            <pb:template xmlns="" xml:space="preserve">        <div class="metadata fragment">
            <h2><pb-i18n key="form.part-fragment"/>  [[count]]</h2>
            <section class="fragment objectDesc">
                <h3><pb-i18n key="form.object-description"/></h3>
                <table>
                    <tbody>
                       [[dimensions]] 
                        <tr>
                            <th><pb-i18n key="form.preservation"/></th>
                            <td><pb-i18n key="[[condition]]"/></td>
                        </tr>
                        <tr>
                            <th><pb-i18n key="form.decoration"/></th>
                            <td>[[decoration]]</td>
                        </tr>
                       <tr>
                            <th><pb-i18n key="form.findspot"/></th>
                            <td>[[findSpot]]</td>
                        </tr>               
                      [[modernPlace]]
                      [[ancientPlace]]
                      [[findContext]]
                        <tr>
                            <th><pb-i18n key="form.year-of-find"/></th>
                            <td>[[findDate]]</td>
                        </tr>
                        <tr>
                            <th><pb-i18n key="form.last-recorded-location"/></th>
                            <td>[[modernLocation]]</td>
                        </tr>
                      [[tmID]] 
                    </tbody>
                </table>                
            </section>
            <section class="fragment inscription">
                <h3><pb-i18n key="form.inscription-field"/></h3>
                <table>
                    <tbody>
                       [[fieldDimensions]]
                         <tr>
                            <th><pb-i18n key="form.letter-size"/></th>
                            <td>[[letterSize]]</td>
                        </tr>
                        [[palaeography]]        
                        <tr>
                            <th><pb-i18n key="form.ligature"/></th>
                            <td>[[ligature]]</td>
                        </tr>                      
                        [[fieldDesc]]
                    </tbody>
                </table>                
            </section>         
            <section class="fragment text">
                <h3><pb-i18n key="form.text-description"/></h3>
                <table>
                    <tbody>                      
                        <tr>
                            <th><pb-i18n key="form.type-of-inscription"/></th>
                            [[inscriptionType]]
                        </tr>
                        <tr>
                            <th><pb-i18n key="form.metre"/></th>
                            <td>[[metre]]</td>
                        </tr>
                        <tr>
                            <th><pb-i18n key="form.language"/></th>
                            <td>[[language]]</td>
                        </tr>
                    </tbody>
                </table>               
            </section>
          <section class="fragment additional">
            <h3><pb-i18n key="metadata.additional"/></h3>
            <table>              
              <tbody>
                <tr>
                            <th><pb-i18n key="form.basis-of-verification"/></th>
                            <td><pb-i18n key="[[verification]]"/></td>
                        </tr>
                        <tr>
                            <th><pb-i18n key="form.date-of-verification"/></th>
                            <td>[[verificationDate]]</td>
                        </tr>    
               [[provenanceHistory]] 
              </tbody>
            </table>
          </section>
          <section class="fragment references">
              [[biblHeader]]
              [[bibl]]
          </section>
        </div></pb:template>
        </model>
                </elementSpec>
                <elementSpec ident="term" mode="add">
                    <model predicate="$parameters?language='en'" behaviour="inline">
            <param name="content" value="string-join(*[@xml:lang eq 'en'], ', ')"/>
        </model>
                    <model predicate="$parameters?language='de'" behaviour="inline">
            <param name="content" value="string-join(*[@xml:lang eq 'de'], ', ')"/>
        </model>
                </elementSpec>
            <elementSpec ident="body" mode="change">
                    <modelSequence>
            <model behaviour="index">
                <param name="type" value="'toc'"/>
            </model>
            <model behaviour="heading">
                <desc>Ordering of div elements</desc>
                <param name="level" value="2"/>
                <pb:template xmlns="" xml:space="preserve"><pb-i18n key="form.edition"/></pb:template>
            </model>
            <model behaviour="block">
                <param name="content" value="div[@type eq 'edition']"/>
            </model>
            <model behaviour="paragraph">
                <param name="content" value="'Edition by ' ||  root(.)/descendant::titleStmt/editor"/>
                <outputRendition xml:space="preserve">
                font-weight:bold
                </outputRendition>
            </model>
            <model predicate="div[@type eq 'apparatus']/node()" behaviour="heading">
                <param name="level" value="2"/>
                <pb:template xmlns="" xml:space="preserve"><pb-i18n key="form.apparatus"/></pb:template>
            </model>
            <model behaviour="block">
                <param name="content" value="div[@type eq 'apparatus']"/>
            </model>
            <model predicate="div[@type eq 'translation']/node()" behaviour="heading">
                <param name="level" value="2"/>
                <pb:template xmlns="" xml:space="preserve"><pb-i18n key="form.translation"/></pb:template>
            </model>
            <model behaviour="block">
                <param name="content" value="div[@type eq 'translation']"/>
            </model>
            <model predicate="div[@resp] and (count(div[@type eq 'translation']) eq 1)" behaviour="paragraph">
                <param name="content" value="'Translated by ' || descendant::div[@type eq 'translation']/@resp"/>
                <outputRendition xml:space="preserve">
                font-weight:bold
                </outputRendition>
            </model>
            <model predicate="div[@type eq 'commentary']/node()" behaviour="heading">
                <param name="level" value="2"/>
                <pb:template xmlns="" xml:space="preserve"><pb-i18n key="form.commentary"/></pb:template>
            </model>
            <model behaviour="block">
                <param name="content" value="div[@type eq 'commentary']"/>
            </model>
            <model predicate="not(root(.)/descendant::facsimile)" behaviour="webcomponent">
                <desc>Hack for the event 'pb-facsimile-status' to return 'fail' when there is no facsimile</desc>
                <param name="name" value="'pb-facs-link'"/>
                <param name="facs" value="'none'"/>
                <param name="emit" value="'transcription'"/>
            </model>
        </modelSequence>
                </elementSpec>
                                <elementSpec ident="choice" mode="change">
                    <model output="print" predicate="sic and corr" behaviour="inline">
            <param name="content" value="corr"/>
        </model>
                    <model output="print" predicate="abbr and expan" behaviour="inline">
            <param name="content" value="expan"/>
        </model>
                    <model output="print" predicate="orig and reg" behaviour="inline">
            <param name="content" value="reg"/>
        </model>
                    <model predicate="$parameters?mode='norm' and sic and corr" behaviour="alternate" cssClass="choice">
            <param name="default" value="sic"/>
            <param name="alternate" value="corr"/>
        </model>
                    <modelSequence predicate="sic and corr">
            <model behaviour="alternate" cssClass="choice">
                <param name="default" value="sic"/>
                <param name="alternate" value="corr"/>
            </model>
            <model behaviour="alternate" cssClass="choice-alternate">
                <param name="default" value="corr"/>
                <param name="alternate" value="sic"/>
            </model>
        </modelSequence>
                    <model predicate="$parameters?mode='norm' and abbr and expan" behaviour="alternate" cssClass="choice">
            <param name="default" value="expan"/>
            <param name="alternate" value="abbr"/>
        </model>
                    <modelSequence predicate="abbr and expan">
            <model behaviour="alternate" cssClass="choice">
                <param name="default" value="abbr"/>
                <param name="alternate" value="expan"/>
            </model>
            <model behaviour="alternate" cssClass="choice-alternate">
                <param name="default" value="expan"/>
                <param name="alternate" value="abbr"/>
            </model>
        </modelSequence>
                    <model predicate="$parameters?mode='norm' and orig and reg" behaviour="alternate" cssClass="choice">
            <param name="default" value="reg"/>
            <param name="alternate" value="orig"/>
        </model>
                    <modelSequence predicate="orig and reg">
            <model behaviour="alternate" cssClass="choice">
                <param name="default" value="orig"/>
                <param name="alternate" value="reg"/>
            </model>
            <model behaviour="alternate" cssClass="choice-alternate">
                <param name="default" value="reg"/>
                <param name="alternate" value="orig"/>
            </model>
        </modelSequence>
                </elementSpec>
            <elementSpec ident="persName" mode="change">
                    <model behaviour="link">
            <param name="uri" value="'/exist/apps/edep/person.html?id=' || @key"/>
        </model>
                </elementSpec>
                 
            <elementSpec ident="bibl" mode="change">
                    <model predicate="$parameters?view='metadata'" behaviour="listItem">
            <param name="content" value="let $url :=  'https://api.zotero.org/groups/2519759/items/top?format=bib&amp;amp;tag=' || ptr/@target || '&amp;amp;style=digital-humanities-im-deutschsprachigen-raum&amp;amp;linkwrap=1' return (hc:send-request(&lt;hc:request method=&#34;GET&#34; href=&#34;{$url}&#34;&gt;&lt;/hc:request&gt;), citedRange)"/>
        </model>
                    <model predicate="parent::listBibl" behaviour="listItem"/>
                    <model behaviour="inline"/>
                </elementSpec>
                <elementSpec ident="listBibl" mode="change">
                    <modelSequence predicate="($parameters?view='metadata') and (@type eq 'previousEditions')">
            <model behaviour="heading">
                <param name="level" value="3"/>
                <pb:template xmlns="" xml:space="preserve"><pb-i18n key="form.previous-editions"/></pb:template>
            </model>
            <model behaviour="list">
                <param name="content" value="bibl"/>
            </model>
        </modelSequence>
                    <modelSequence predicate="($parameters?header='metadata') and (@type eq 'transmission')">
            <model behaviour="heading">
                <param name="level" value="3"/>
                <pb:template xmlns="" xml:space="preserve"><pb-i18n key="form.transmission"/></pb:template>
            </model>
            <model behaviour="inline">
                <param name="content" value="bibl"/>
            </model>
        </modelSequence>
                    <modelSequence predicate="($parameters?view='metadata') and (@type eq 'bibliography')">
            <model behaviour="heading">
                <param name="level" value="3"/>
                <pb:template xmlns="" xml:space="preserve"><pb-i18n key="form.bibliography"/></pb:template>
            </model>
            <model behaviour="inline">
                <param name="content" value="bibl"/>
            </model>
        </modelSequence>
                    <modelSequence predicate="($parameters?view='metadata') and (@type eq 'images')">
            <model behaviour="heading">
                <param name="level" value="3"/>
                <pb:template xmlns="" xml:space="preserve"><pb-i18n key="form.images-dps"/></pb:template>
            </model>
            <model behaviour="inline">
                <param name="content" value="bibl"/>
            </model>
        </modelSequence>
                    <model predicate="bibl" behaviour="list">
            <param name="content" value="bibl"/>
        </model>
                    <model behaviour="block"/>
                </elementSpec>

            <elementSpec ident="ref" mode="change">
                    <model predicate="not(@target)" behaviour="inline"/>
                    <model predicate="not(node())" behaviour="link">
            <param name="content" value="@target"/>
            <param name="uri" value="@target"/>
        </model>
                    <model behaviour="link">
            <param name="uri" value="@target"/>
        </model>
                </elementSpec>
                <elementSpec ident="graphic" mode="change">
                    <model predicate="$parameters?view='facsimile'" behaviour="inline">
            <param name="facs" value="@url"/>
            <param name="content" value="let $id := parent::facsimile/substring(@corresp, 2)  let $msPart := root(.)/descendant::msPart[@xml:id = $id]  let $type := $msPart/@type let $count := count(preceding-sibling::graphic) + 1 let $countFragment:= if ($type eq 'fragment') then count($msPart/preceding-sibling::msPart[@type eq 'fragment']) + 1 else () return if ($type eq 'main') then $count else $count || '(fragment ' || $countFragment || ')'"/>
            <param name="uri" value="'https://heidicon.ub.uni-heidelberg.de/detail/' || substring-before(@url, '%')"/>
            <pb:template xmlns="" xml:space="preserve"><a href="#">
  <pb-facs-link facs="[[facs]]" emit="transcription" trigger="click">
    <pb-popover>[[content]]
    <template slot="alternate"><a href="[[uri]]" target="_blank">See details</a></template></pb-popover>
  </pb-facs-link>
</a></pb:template>
        </model>
                </elementSpec>
                <elementSpec ident="facsimile" mode="add">
                    <model predicate="$parameters?view='facsimile'" behaviour="block" cssClass="facs">
            <param name="content" value="graphic"/>
            <pb:template xmlns="" xml:space="preserve"><h3>Images</h3><p class="facsLinks">[[content]]</p></pb:template>
        </model>
                </elementSpec>
            <elementSpec ident="app" mode="add">
                    <model predicate="parent::listApp" behaviour="listItem"/>
                </elementSpec>
                <elementSpec ident="listApp" mode="add">
                    <model behaviour="list"/>
                </elementSpec>
                <elementSpec ident="note" mode="change">
                    <model predicate="parent::app" behaviour="inline"/>
                    <model predicate="&#34;sic&#34;" behaviour="inline">
            <param name="inside" value="."/>
            <param name="content" value="&#34;(!)&#34;"/>
            <outputRendition xml:space="preserve">
            color:red;
            </outputRendition>
        </model>
                    <model behaviour="note">
            <param name="place" value="@place"/>
            <param name="label" value="@n"/>
            <outputRendition xml:space="preserve">
            
            </outputRendition>
        </model>
                </elementSpec>
            </schemaSpec>
        </body>
    </text>
</TEI>